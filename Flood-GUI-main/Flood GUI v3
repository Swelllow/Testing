repeat wait() until game:IsLoaded() or game.Loaded:wait()
--anticheat bypass all credits to altlexon
game:GetService("ReplicatedStorage").Remote.ReqCharVars.OnClientInvoke = function()return{}end

-- map list extractor
getgenv().maps = {}
local script = require(game.ReplicatedStorage.SharedModules.FE2Library)
for i,v in pairs(script.getOfficialMapData()) do
	table.insert(maps,v.mapName)
end
wait = task.wait

local clmain = getsenv( game.Players.LocalPlayer.PlayerScripts["CL_MAIN_GameScript"] )
local save = clmain.newAlert
if getgenv().wow and debugmode == false then
	clmain.newAlert('Already Executed!',Color3.new(1,0,0))
    error('Already Executed')
else
    getgenv().wow=''
end
-- TAS file minifier 
-- Starting from this line to ending line code was made by ian
local HttpService = game:GetService("HttpService")
local function round(x)
    local factorOfTen = 10^(3)
    return math.floor(x * factorOfTen + .5) / factorOfTen
end
local function minfile(file)
    local tasFile = HttpService:JSONDecode(file)
    local minTasFile = {}
    for t,data in ipairs(tasFile) do
        local minData = {}
        for key,val in pairs(data) do
            local minVal = nil
            if type(val) == "table" then
                minVal = {}
                for f,x in ipairs(val) do
                    if type(x) == "number" then table.insert(minVal, round(x))
                    else table.insert(minVal, x) end    
                end
            else
                minVal = round(val)
            end
            minData[key] = minVal
        end
        table.insert(minTasFile, minData)
    end
    return HttpService:JSONEncode(minTasFile)
end
-- ending line
local char = game.Players.LocalPlayer.Character or game.Players.LocalPlayer.CharacterAdded:wait()
local bb = game:service'VirtualUser'
game:service'Players'.LocalPlayer.Idled:connect(function()
	bb:CaptureController()
	bb:ClickButton2(Vector2.new())
end)
-- new anticheat bypass all credits to altlexon
game.ReplicatedStorage.Remote.ReqCharVars.OnClientInvoke = function()
	return {}
end
getgenv().oof = false
local votemap = game.Players.LocalPlayer.PlayerGui.GameGui.VoteMap
local key = -game:GetService("ReplicatedStorage").Remote.ReqPasskey:InvokeServer()
function vote()
	wait(1)
	game:GetService("ReplicatedStorage").Remote.UpdMapVote:FireServer(key, 8, 0)
	if not game.Workspace.Multiplayer:WaitForChild("NewMap", 7) then
		game:GetService("ReplicatedStorage").Remote.UpdMapVote:FireServer(key, 2, 0)
	end
end
game.Players.PlayerAdded:Connect(function()
	if getgenv().autoleave == true then
		game.Players.LocalPlayer:Kick("Auto-Leave is enabled. So you were kicked because a player joined.")	
	end
end)
votemap.Changed:Connect(function(change)
	if change == "Visible" then
		if votemap.Visible == true and getgenv().oof == true then
			print("Voting..")
			wait()
			vote()
		end
	end
end)
print("Loaded!")
local lp = game.Players.LocalPlayer
local TweenService = game:GetService("TweenService")
local TS = game:GetService("TweenService")
local function Time(targetpos)
	local tme = (targetpos - lp.Character.HumanoidRootPart.Position).Magnitude / math.random(16, 20)
	return tme
end
local function tween(pos)
	local toof = TS:Create(lp.Character.HumanoidRootPart, TweenInfo.new(Time(pos), Enum.EasingStyle.Linear, Enum.EasingDirection.Out), {
		CFrame = CFrame.new(pos)
	})
	toof:Play()
	return toof
end

local UIS = game:GetService'UserInputService'
local Library = loadstring(game:HttpGet("https://raw.githubusercontent.com/xHeptc/Kavo-UI-Library/main/source.lua"))()
local colors = {
    SchemeColor = Color3.fromRGB(0, 100, 255),
	Background = Color3.fromRGB(40, 40, 40),
	Header = Color3.fromRGB(30, 30, 30),
	TextColor = Color3.fromRGB(255, 255, 255),
	ElementColor = Color3.fromRGB(60, 60, 60)
}
local Window = Library.CreateLib("Flood GUI v3", colors)
local a = Window:NewTab("Auto")
local l = Window:NewTab("Local-Player")
local b = Window:NewTab("Blatant")
local t = Window:NewTab("TAS")
local k = Window:NewTab("Other")
local c = Window:NewTab("Credits")
local auto = a:NewSection("Auto")
local loc = l:NewSection("Local Player")
local blatant = b:NewSection("Blatant")
local tas = t:NewSection("TAS")
local other = k:NewSection("Other")
local credits = c:NewSection("Credits")
getgenv().wow = true
other:NewKeybind("ToggleUI", "Toggle UI with this keybind.", Enum.KeyCode.J, function()
	if getgenv().ui == true then
		clmain.newAlert("UI Disabled!", Color3.fromRGB(255, 0, 0))
		getgenv().ui = false
	else
		clmain.newAlert("UI Enabled!", Color3.fromRGB(0, 60, 255))
		getgenv().ui = true
	end
	Library:ToggleUI()
end)
other:NewLabel("Discord Invites")
other:NewButton("Copy Tomato-Hub Invite", "Copies Tomato-Hub invite to clipboard!", function()
	setclipboard("https://discord.gg/8N2M9fHJqa")
end)
other:NewButton("Copy Lexon-Hub Invite", "Copies Lexon-Hub invite to clipboard!", function()
	setclipboard("https://discord.gg/ng4CN7Vq")
end)
getgenv().ui = true
loc:NewSlider("Walkspeed", "Change your walkspeed!", 100, 20, function(t)
	game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = t
end)
loc:NewSlider("JumpPower", "Change your jumppower!", 200, 50, function(t)
	game.Players.LocalPlayer.Character.Humanoid.JumpPower = t
end)
loc:NewToggle("Teleport on Ctrl+Click ⚠️", "Toggle teleport on Ctrl+Click", function(toggled)
    TeleportEnabled = toggled
end)

local UIS = game:GetService("UserInputService")
local Player = game.Players.LocalPlayer
local Mouse = Player:GetMouse()

function GetCharacter()
    return game.Players.LocalPlayer.Character
end

function Teleport(pos)
    local Char = GetCharacter()
    if Char then
        Char:MoveTo(pos)
    end
end

local function InputHandler(input)
    if TeleportEnabled and input.UserInputType == Enum.UserInputType.MouseButton1 and UIS:IsKeyDown(Enum.KeyCode.LeftControl) then
        Teleport(Mouse.Hit.p)
    end
end

UIS.InputBegan:Connect(InputHandler)

loc:NewKeybind("Vip Emote", "Activates Vip emote!", Enum.KeyCode.V, function()
    local character = game:GetService("Players").LocalPlayer.Character
    local humanoid = character:WaitForChild("Humanoid")

    local animation = Instance.new("Animation")
    animation.AnimationId = "rbxassetid://1584520816"

    local emoteAnimationTrack = humanoid:LoadAnimation(animation)

    game:GetService("UserInputService").InputBegan:Connect(function(input)
        if input.KeyCode == Enum.KeyCode.V then
            emoteAnimationTrack:Play()
            wait()
        end
        if input.KeyCode == Enum.KeyCode.W then
            emoteAnimationTrack:Stop()
            wait()
        end
        if input.KeyCode == Enum.KeyCode.A then
            emoteAnimationTrack:Stop()
            wait()
        end
        if input.KeyCode == Enum.KeyCode.S then
            emoteAnimationTrack:Stop()
            wait()
        end
        if input.KeyCode == Enum.KeyCode.D then
            emoteAnimationTrack:Stop()
            wait()
        end
    end)
end)

local save = getsenv(game:GetService("Players").LocalPlayer.PlayerScripts["CL_MAIN_GameScript"]).takeAir
getgenv().godmode = false
spawn(function()
	while wait(.04) do
		if getgenv().godmode == true then
			getsenv(game:GetService("Players").LocalPlayer.PlayerScripts["CL_MAIN_GameScript"]).takeAir = function()
				return 0
			end
		else
			getsenv(game:GetService("Players").LocalPlayer.PlayerScripts["CL_MAIN_GameScript"]).takeAir = save
		end
	end
end)
blatant:NewKeybind("Infinite Air", "Infinite Air/God Mode", Enum.KeyCode.R, function()
	if getgenv().godmode ~= false then
		clmain.newAlert("Infinite Air Disabled!", Color3.fromRGB(255, 0, 0))
		getgenv().godmode = false
	else
		clmain.newAlert("Infinite Air Enabled!", Color3.fromRGB(0, 255, 0))
		getgenv().godmode = true
	end
end)

local lp = game:GetService("Players").LocalPlayer
local noclipEnabled = false

game:GetService("RunService").Stepped:Connect(function()
    if noclipEnabled and lp.Character then
        for _, part in pairs(lp.Character:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = false
            end
        end
    end
end)

blatant:NewKeybind("Noclip", "Walk through some walls!", Enum.KeyCode.G, function()
    noclipEnabled = not noclipEnabled
    if noclipEnabled then
        clmain.newAlert("Noclip Enabled!", Color3.fromRGB(0, 255, 0))
    else
        clmain.newAlert("Noclip Disabled!", Color3.fromRGB(255, 0, 0))
    end
end)

blatant:NewButton("Lag Server", "Equip buddy then press", function()
	local key = -game:GetService("ReplicatedStorage").Remote.ReqPasskey:InvokeServer()
	for i = 1, 190, 1 do
		game:GetService("ReplicatedStorage").Remote.ConfirmItem:FireServer(key, 40)
	end
end)
local camera = game.Workspace.CurrentCamera
local targetPosition = Vector3.new(-25.5, -144.3449249267578, 138.50001525878906)
local play = false
local useCamera = false

local camera = game.Workspace.CurrentCamera

-- Define the target position
local targetPosition = Vector3.new(-25.5, -144.3449249267578, 138.50001525878906)

auto:NewToggle("Auto-Play [Working]", "Will auto-play maps with a TAS! (Requires TAS files)", function(t)
	getgenv().play = t
end)

local player = game.Players.LocalPlayer
local character = player.Character
local camera = workspace.CurrentCamera

getgenv().camera = false

task.spawn(function()
    while task.wait() do
        if getgenv().camera then
            local newLookVector = (targetPosition - camera.CFrame.p).Unit
            camera.CFrame = CFrame.new(camera.CFrame.p, camera.CFrame.p + newLookVector)
        end
    end
end)

auto:NewToggle("Camera", "Constantly looks at elevator!", function()
    getgenv().camera = not getgenv().camera
end)

local autoWalkEnabled = false

local function autoWalk()
    while autoWalkEnabled do
        local character = player.Character
        if character and character:FindFirstChild("Humanoid") then
            local direction = camera.CFrame.lookVector
            local targetPos = character.HumanoidRootPart.Position + direction * 2
            character.Humanoid:MoveTo(targetPos)
        end
        wait()
    end
end

auto:NewToggle("Auto-Walk", "Will automatically walk forward for you!", function()
    autoWalkEnabled = not autoWalkEnabled
    if autoWalkEnabled then
        spawn(autoWalk)
    end
end)

player.CharacterAdded:Connect(function(character)
    autoWalk()
end)

getgenv().play = false
getgenv().infjump = false
getgenv().oof = false

local vuEnabled = false

local VirtualUser = game:GetService("VirtualUser")

auto:NewToggle("Anti-Afk", "Prevents AFK kick", function(t)
    if t then
        game:GetService("Players").LocalPlayer.Idled:connect(function()
            VirtualUser:CaptureController()
            VirtualUser:ClickButton2(Vector2.new())
        end)
    end
end)

local autoPlayEnabled = false

loc:NewToggle("Anti-Fog", "Will automatically remove the fog!", function(t)
    autoPlayEnabled = t
    while autoPlayEnabled do
        game.Lighting.FogEnd = 100000
        game.Lighting.FogStart = 0
        game.Lighting.ClockTime = 14
        game.Lighting.Brightness = 2
        game.Lighting.GlobalShadows = false
        wait(1) -- Wait for one second before running the loop again
    end
end)

task.spawn(function()
	while task.wait(.5) do
		local S,r = pcall(function()
			if getgenv().play then
				local Mirrored = false
local SkipMirroredMaps = {
    ["Retro Coast"] = true,
    ["Zemblanity"] = true,
    ["Shimmering Delta"] = true,
    ["Northren Mill"] = true,
    ["Mysterium"] = true,
    ["Oil Outpost"] = true,
    ["Sinister Labyrinth"] = true,
    ["Snowy Stronghold"] = true,
    ["Choaz Japan"] = true,
    ["Decaying Silo"] = true,
    ["Active Volcanic Mines"] = true
}
local NewV = Vector3.new
local NewC = CFrame.new
local AngC = CFrame.fromEulerAnglesXYZ
local LP = game.Players.LocalPlayer
local Alert = getsenv(LP.PlayerScripts.CL_MAIN_GameScript).newAlert
local Multi = Workspace.Multiplayer
local RS = game:GetService('RunService')
local wait = task.wait

-- IMPORTANT
local CLMAIN = getsenv(LP.PlayerScripts.CL_MAIN_GameScript)
CLMAIN.newAlert("TAS Player Started.")
local Animate = getsenv(LP.Character.Animate)
local RunName = Multi:WaitForChild('NewMap'):WaitForChild('Settings'):WaitForChild('MapName').Value
local TAS = game:GetService("HttpService"):JSONDecode(readfile(RunName .. ".json"))
CLMAIN.newAlert("TAS Loaded!")
local Map = Multi:WaitForChild("Map")
local mapName = Map:WaitForChild('Settings').MapName.Value

if SkipMirroredMaps[mapName] then
    CLMAIN.newAlert('Mirrored script skipped for map: ' .. mapName)
else
    if Map:WaitForChild('Settings'):FindFirstChild("_MirrorMap") then
        CLMAIN.newAlert('Map is not mirrored.')
        Mirrored = false
    else
        CLMAIN.newAlert('Map is mirrored, TAS will be played mirrored!')
        Mirrored = true
    end
end

local Spawn = (function() -- this whole function was made by Epix
        local Workspace = game:GetService("Workspace")
        local character = LP.Character
        local characterPosition = character.HumanoidRootPart.Position -- only need to evaluate this once

        -- Get parts that have the character above them

        -- Part that's supposed to represent the character's "feet"
        local dummyPart = Instance.new("Part")
        dummyPart.Size = Vector3.one
        dummyPart.Position = characterPosition - (Vector3.yAxis * 2)
        dummyPart.Anchored = true
        dummyPart.CanCollide = false
        dummyPart.Parent = Workspace

        local overlapParams = OverlapParams.new()
        overlapParams.FilterDescendantsInstances = {dummyPart} -- Only checking if bounding area intersects with "feet"
        overlapParams.FilterType = Enum.RaycastFilterType.Whitelist

        local spawnCandidates = table.create(10) -- create an empty table with size 10
        local numCandidates = 0 -- track the number of candidates added to the table

        -- loop over the parts to find spawn candidates
        for _, item in next, Map:GetDescendants() do
          -- check if the item is a valid spawn candidate
          if item:IsA("BasePart") and (item.Position - characterPosition).Magnitude <= 10 then
             -- check if the part is flipped upside down
                local facingUpVector = item.CFrame.UpVector:Dot(Vector3.yAxis) >= 0 and item.CFrame.UpVector or -item.CFrame.UpVector

               -- get the candidates in the area around the part
               local candidatesInArea = Workspace:GetPartBoundsInBox(
            item.CFrame + (facingUpVector * (item.Size.Y/2 + 0.25)),
                   Vector3.new(item.Size.X, 0.5, item.Size.Z),
                 overlapParams
               )

              -- add any valid candidates to the table
             for _, candidate in next, candidatesInArea do
                    if candidate == dummyPart then
                        numCandidates = numCandidates + 1
                      spawnCandidates[numCandidates] = item
                     break
                  end
               end
           end
        end

        -- get the spawn candidate from the table
        if numCandidates >= 1 then
           -- prioritize invisible spawn parts parented to the map
           for i = 1, numCandidates do
               local spawnCandidate = spawnCandidates[i]
              if spawnCandidate.CanCollide and (spawnCandidate.Transparency >= 0.8 or spawnCandidate.Parent == Map) then
                  return spawnCandidate
               end
          end

           -- second pass: only needs to be CanCollide
           for i = 1, numCandidates do
             local spawnCandidate = spawnCandidates[i]
             if spawnCandidate.CanCollide then
                 return spawnCandidate
             end
         end

         -- fall back to first in list
           return spawnCandidates[1]
        else
          error("Failed to find spawn part!")
        end
end)()
LP.Character.HumanoidRootPart.CFrame = NewC(TAS[3].CCFrame[1], TAS[3].CCFrame[2], TAS[3].CCFrame[3]) * AngC(TAS[3].CCFrame[4], TAS[3].CCFrame[5], TAS[3].CCFrame[6]) + NewV(Spawn.Position.X, Spawn.Position.Y - 1000, Spawn.Position.Z)
LP.Character.HumanoidRootPart.Velocity = NewV(TAS[3].VVelocity[1], TAS[3].VVelocity[2], TAS[3].VVelocity[3])
Workspace.CurrentCamera.CFrame = NewC(TAS[3].CCameraCFrame[1], TAS[3].CCameraCFrame[2], TAS[3].CCameraCFrame[3]) * AngC(TAS[3].CCameraCFrame[4], TAS[3].CCameraCFrame[5], TAS[3].CCameraCFrame[6]) + NewV(Spawn.Position.X, Spawn.Position.Y - 1000, Spawn.Position.Z)

game:GetService("ReplicatedStorage").Remote.StartClientMapTimer.OnClientEvent:Wait()
local TimeStart = os.clock()
CLMAIN.newAlert('TAS Running..')
PlayAnim = Animate.playAnimation
Animate.playAnimation = function()end

for _, v in next, Map:GetDescendants() do
    if v.Name == 'ButtonIcon' then
        local buttonPart = v.Parent.Parent:FindFirstChildOfClass('Part')
        if buttonPart ~= nil then
            buttonPart.Size = Vector3.new(6,6,6)
            if debugmode == true then
                buttonPart.Color = Color3.new(0,0,1)
                buttonPart.Transparency = 0
            end
        end
    end
end

local RayParts = Instance.new('Model')
RayParts.Name = "RayParts"
RayParts.Parent = Workspace
    local radius = 0.05
    local function MakeRayVisible(ray,color)
        local midpoint = ray.Origin + ray.Direction/2

        local part = Instance.new("Part")
        part.CanCollide = false
        part.CanTouch = false
        part.Parent = RayParts
        part.Anchored = true
        part.CFrame = CFrame.new(midpoint, ray.Origin)
        part.Size = Vector3.new(radius,radius, ray.Direction.Magnitude)

        part.Material = Enum.Material.Neon
        part.Color = color

        return part
    end


local Offset = Spawn.Position - NewV(0, 1000, 0)
local DiffAnim = 0
local OldFrame = 3



local Loop
local Death
Death = LP.Character.Humanoid.Changed:Connect(function(Change)
    if Change == "Health" and LP.Character.Humanoid.Health == 0 then
        Death:Disconnect()
        Loop:Disconnect()
        RayParts:Destroy()
        CLMAIN.newAlert('Player Died.',Color3.new(1,0,0))
    end
end)
Loop = RS.Heartbeat:connect(function(DeltaTime)
    local NewFrame = #TAS
    local Divider = OldFrame + 60
    if Divider < NewFrame then
        NewFrame = Divider
    end
    for i = OldFrame, NewFrame do
        if (os.clock() - TimeStart) < TAS[i].time then
            break
        elseif i >= #TAS then
            Death:Disconnect()
            Loop:Disconnect()
            RayParts:Destroy()
            Animate.playAnimation = PlayAnim
            CLMAIN.newAlert('TAS Run Finished!',Color3.new(0,1,0))
            CLMAIN.newAlert('TAS Player By Tomato',Color3.new(0,1,0))
        elseif (os.clock() - TimeStart) >= TAS[i].time then
            OldFrame = i
            local CF = TAS[i].CCFrame
            local CCF = TAS[i].CCameraCFrame
            local VV = TAS[i].VVelocity
            if Mirrored == true then
                local nCF = CF
                CF[1] = nCF[1]
   		        CF[2] = nCF[2]
    		    CF[3] = -nCF[3]
    		    CF[4] = nCF[4]
    		    CF[5] = nCF[5]
    		    CF[6] = -nCF[6]
    		    VV[3] = -VV[3]
    		    CCF[3] = -CCF[3]
            end

            local CA = TAS[i].AAnimation
            LP.Character.HumanoidRootPart.CFrame = NewC(CF[1], CF[2], CF[3]) * AngC(CF[4], CF[5], CF[6]) + Offset
            LP.Character.HumanoidRootPart.Velocity = NewV(VV[1], VV[2], VV[3])
            Workspace.CurrentCamera.CFrame = NewC(CCF[1], CCF[2], CCF[3]) * AngC(CCF[4], CCF[5], CCF[6]) + Offset
            if TAS[i].AAnimation and TAS[i].AAnimationChanged and TAS[i].AAnimationChanged > DiffAnim then
                if CA[1] == "walk" then
                    PlayAnim(CA[1], CA[2], LP.Character.Humanoid)
                    DiffAnim = TAS[i].AAnimationChanged
                    Animate.setAnimationSpeed(0.76)
                elseif CA[1] == "climb" then
                else
                    PlayAnim(CA[1], CA[2], LP.Character.Humanoid)
                    DiffAnim = TAS[i].AAnimationChanged
                end
            end
        end
    end
end)

if debugmode == true then
    for i = 1, #TAS do
        local function ToCFrame(CF)
            return NewC(CF[1], CF[2], CF[3]) * AngC(CF[4], CF[5], CF[6]) + Offset
        end
        local origin = ToCFrame(TAS[i].CCFrame).Position
        local ray = Ray.new(origin, ToCFrame(TAS[i].CCFrame).Position - origin)
        MakeRayVisible(ray,Color3.new(1,0,0))
    end
end
			end
		end)
		if S ~= true then
			print(r)
		end
	end
end)

local infJumpEnabled = false

blatant:NewToggle("Infinite Jump", "Jump while freefalling!", function()
    infJumpEnabled = not infJumpEnabled
end)

game:GetService("UserInputService").InputBegan:Connect(function(input, gameProcessedEvent)
    if infJumpEnabled and not gameProcessedEvent then
        if input.KeyCode == Enum.KeyCode.Space then
            lp.Character.Humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
        end
    end
end)

auto:NewToggle("Auto-Vote", "Automatically votes! (Will spend coins)", function(t)
	getgenv().oof = t
end)

auto:NewButton("Get TAS files", "Downloads TAS files!", function()
    print("Starting downloads..")
    for i, v in pairs(maps) do
        print("-------------------------------------------------")
        local map = string.gsub(v, " ", "%%20")
        local su = false -- isfile(v..".json")
        if su == true then
            clmain.newAlert(v.." TAS file already exists!",Color3.fromRGB(50,100,255))
        else
            local s, r = pcall(function()
                local tas = game:HttpGet("https://raw.githubusercontent.com/Swelllow/Testing/main/Flood-GUI-main/TAS%20FILES/"..map..".json")
                writefile(v..".json", minfile(tas),true)
            end)
            if s then
                clmain.newAlert("Downloaded "..v.." TAS file succesfully!",Color3.fromRGB(0,255,0))
            else
                clmain.newAlert("Failed to download "..v.." TAS file. :(",Color3.fromRGB(255,0,0))
            end
        end
        task.wait()
    end
    clmain.newAlert("Finished Downloading TAS files")
end)

tas:NewButton('Fix Create-TAS', 'Fix', function()
    local Workspace = game:GetService('Workspace')
    local LP = game.Players.LocalPlayer
    if Workspace.Multiplayer:FindFirstChild('Map') then
        Workspace.Multiplayer.Map:Destroy()
    end
    local Map = Workspace.Multiplayer:WaitForChild('Map')
    local Spawn = (function() -- this whole function was made by Epix
            local Workspace = game:GetService("Workspace")
            local character = LP.Character
            local characterPosition = character.HumanoidRootPart.Position -- only need to evaluate this once
    
            -- Get parts that have the character above them
    
            -- Part that's supposed to represent the character's "feet"
            local dummyPart = Instance.new("Part")
            dummyPart.Size = Vector3.one
            dummyPart.Position = characterPosition - (Vector3.yAxis * 2)
            dummyPart.Anchored = true
            dummyPart.CanCollide = false
            dummyPart.Parent = Workspace
    
            local overlapParams = OverlapParams.new()
            overlapParams.FilterDescendantsInstances = {dummyPart} -- Only checking if bounding area intersects with "feet"
            overlapParams.FilterType = Enum.RaycastFilterType.Whitelist
    
            local spawnCandidates = table.create(10)
            for _, item in next, Map:GetDescendants() do
                if not item:IsA("BasePart") or (item.Position - characterPosition).Magnitude > 10 then
                    break
                end
    
                -- If the part is flipped upside down, that is a problem, thus there is a check here
                local facingUpVector
                if item.CFrame.UpVector:Dot(Vector3.yAxis) >= 0 then facingUpVector = item.CFrame.UpVector else facingUpVector = -item.CFrame.UpVector end
                local candidatesInArea = Workspace:GetPartBoundsInBox(
                    item.CFrame + (facingUpVector * (item.Size.Y/2 + 0.25)),
                    Vector3.new(item.Size.X, 0.5, item.Size.Z),
                    overlapParams
                )
                for _, candidate in next, candidatesInArea do
                    if candidate == dummyPart then
                        table.insert(spawnCandidates, item)
                    end
                end
            end
    
            dummyPart:Destroy()
    
            if #spawnCandidates >= 1 then
                -- Prioritize invisible spawn parts parented to the map
                for _, spawnCandidate in next, spawnCandidates do
                    if spawnCandidate.CanCollide and (spawnCandidate.Transparency >= 0.8 or spawnCandidate.Parent == map) then
                        return spawnCandidate
                    end
                end
                -- Second pass: only needs to be CanCollide
                for _, spawnCandidate in next, spawnCandidates do
                    if spawnCandidate.CanCollide then
                        return spawnCandidate
                    end
                end
                -- Fall back to first in list
                return spawnCandidates[1]
            else
                error("Failed to find spawn part!")
            end
    end)()
    
Spawn.Name = "Spawn"
end)

tas:NewButton("Create-TAS", "Create a TAS, Press then enter lift.", function()
	game.Workspace.DescendantAdded:Connect(function(child)
		if child.ClassName == "Sound" then
			child:Destroy()
		end
	end)
	local Fix = coroutine.wrap(function()
		loadstring(game:HttpGet("https://gist.githubusercontent.com/ExploitOnYt/87466f9b6f9333449c683643e59fdf94/raw/440d5306e1aa87f1ba20e94be005bffe945e0f8a/Tas", true))()
	end)
        local ButtonStuff = coroutine.wrap(function()
            for i,v in pairs(game.Workspace:WaitForChild("Map"):GetDescendants()) do
                if v.ClassName == "Part" and v.Size == Vector3.new(3,1,3) then 
                    v.Size = v.Size * 1.8
                    v.Color = Color3.fromRGB(255,140,0)
                    local selectbox = Instance.new("SelectionBox", v)
                    selectbox.Adornee = v
                    selectbox.Color3 = Color3.fromRGB(255,140,0)
                    getgenv().delayy = false
                    v.Touched:Connect(function(part)
                        if delayy == false then
                            clmain.newAlert("Button Touched!",Color3.fromRGB(255,140,0))
                            delayy = true
                            wait(1)
                            delayy = false
                        end
                    end)
                end
            end
        end)
	Fix()
	ButtonStuff()
end)
tas:NewButton("Run-TAS", "Press then enter lift!", function()
	loadstring(game:HttpGet('https://raw.githubusercontent.com/Swelllow/Testing/main/Flood-GUI-main/TAS/TAS%20Player'))
	"TAS Player Fixed By Tomato with help from Epix"
end)


local oldindex
oldindex = hookmetamethod(game, "__index", function(self, b)
	if tostring(self) == "HumanoidRootPart" and b == "Position" and not checkcaller() then
		if getgenv().swim == true then
			return Vector3.new(-23, -153, 0) -- position of lobby water
		else
			return oldindex(self, b) -- normal player position
		end
	end
	return oldindex(self, b)
end)
tas:NewKeybind("Toggle Swim", "Only works while creating TAS.", Enum.KeyCode.T, function()
	if getgenv().swim == true then
		getgenv().swim = false
	else
		getgenv().swim = true
	end
end)
tas:NewButton("Remove Water (TAS)", "Removes water in tas creator", function()
    for i,v in pairs(game.Workspace:GetDescendants()) do
        if string.match(string.lower(v.Name),"water") then
            v:Destroy()
        end
    end
end)
tas:NewToggle("Auto-Leave", "Automatically leaves when player joins!", function(t)
	getgenv().autoleave = t
end)
credits:NewLabel("New Anti-Kick by AltLexon#6917")
credits:NewLabel("TAS script by Voiz#5668 and Moz")
credits:NewLabel("TAS File Minifier by iaan#8193")
credits:NewLabel("Tas Player by Tomato and Moz")
credits:NewLabel("Other small things by Moz")
credits:NewLabel("Everything else by Tomato")
wait()
if debugmode == true then
	clmain.newAlert("Flood GUI v3 loaded in Debug Mode!",Color3.new(0,0,1))
else
	clmain.newAlert("Flood GUI v3 Loaded!",nil,nil,"rainbow")
end
local oldwrite; oldwrite = hookfunction(writefile,function(name,data,bypass)
    if bypass ~= true then
        local Mn = string.gsub(name,'.json','')
        if table.find(maps,Mn) then
            clmain.newAlert("Saved "..Mn.." TAS file!",nil,nil,"rainbow")
            return oldwrite(name,minfile(data))
        end
    end
    return oldwrite(name,data)
end)


--resets character to fix lag bug wow
game.Players.LocalPlayer.Character:WaitForChild("Humanoid").Health = 0
