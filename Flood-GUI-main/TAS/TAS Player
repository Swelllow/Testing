-- Assign commonly used functions and objects to variables for faster access
local newVector3 = Vector3.new
local newCFrame = CFrame.new
local angCFrame = CFrame.fromEulerAnglesXYZ
local httpService = game:GetService("HttpService")
local multi = Workspace.Multiplayer
local localPlayer = game.Players.LocalPlayer
local clMainGameScript = localPlayer.PlayerScripts.CL_MAIN_GameScript
local alertFunc = getsenv(clMainGameScript).newAlert
local animateFunc = getsenv(localPlayer.Character.Animate)
local mapSettings = multi.Map.Settings

-- Log script start and load TAS file
alertFunc("TAS Player Started.")
local runName = multi.NewMap.Settings.MapName.Value
local tas = httpService:JSONDecode(readfile(runName .. ".json"))
alertFunc("TAS Loaded!")

-- Check if map is mirrored and log status
local mirrored = mapSettings:FindFirstChild("_MirrorMap") ~= nil
if mirrored then
    alertFunc('Map is mirrored, TAS will be played mirrored!')
else
    alertFunc('Map is not mirrored.')
end

local Workspace = game:GetService("Workspace")
local character = LP.Character
local characterPosition = character.HumanoidRootPart.Position -- only need to evaluate this once

-- Get parts that have the character above them

-- Part that's supposed to represent the character's "feet"
local dummyPart = Instance.new("Part")
dummyPart.Size = Vector3.new(1, 1, 1)
dummyPart.Position = characterPosition - (Vector3.new(0, 2, 0))
dummyPart.Anchored = true
dummyPart.CanCollide = false
dummyPart.Parent = Workspace

local overlapParams = OverlapParams.new()
overlapParams.FilterDescendantsInstances = {dummyPart} -- Only checking if bounding area intersects with "feet"
overlapParams.FilterType = Enum.RaycastFilterType.Whitelist

local spawnCandidates = {}
for _, item in pairs(Map:GetDescendants()) do
    if item:IsA("BasePart") and (item.Position - characterPosition).Magnitude <= 10 then
        -- If the part is flipped upside down, that is a problem, thus there is a check here
        local facingUpVector = item.CFrame.UpVector:Dot(Vector3.new(0, 1, 0)) >= 0 and item.CFrame.UpVector or -item.CFrame.UpVector
        local candidatesInArea = Workspace:GetPartBoundsInBox(
            item.CFrame + (facingUpVector * (item.Size.Y/2 + 0.25)),
            Vector3.new(item.Size.X, 0.5, item.Size.Z),
            overlapParams
        )
        for _, candidate in pairs(candidatesInArea) do
            if candidate == dummyPart then
                table.insert(spawnCandidates, item)
                break
            end
        end
    end
end

dummyPart:Destroy()

local overlapParams = OverlapParams.new()
overlapParams.FilterType = Enum.RaycastFilterType.Whitelist

local Spawn = (function()
    local character = LP.Character
    local characterPosition = character.HumanoidRootPart.Position

    overlapParams.FilterDescendantsInstances = {character.HumanoidRootPart}

    local spawnCandidates = {}

    for _, item in ipairs(Map:GetDescendants()) do
        if not item:IsA("BasePart") then
            -- Skip non-BaseParts
        elseif (item.Position - characterPosition).Magnitude > 10 then
            -- Skip parts that are too far from the player
        else
            local facingUpVector = item.CFrame.UpVector
            if facingUpVector:Dot(Vector3.yAxis) < 0 then
                facingUpVector = -facingUpVector
            end

            local partBounds = item:GetRenderCFrame()
            partBounds = partBounds + (facingUpVector * (item.Size.Y/2 + 0.25))
            partBounds = partBounds:ExpandToGrid(4)

            if Workspace:QueryRegion3(partBounds, overlapParams) then
                spawnCandidates[#spawnCandidates+1] = item
            end
        end
    end

    if #spawnCandidates >= 1 then
        -- Prioritize invisible spawn parts parented to the map
        for _, spawnCandidate in ipairs(spawnCandidates) do
            if spawnCandidate.CanCollide and (spawnCandidate.Transparency >= 0.8 or spawnCandidate.Parent == map) then
                return spawnCandidate
            end
        end
        -- Second pass: only needs to be CanCollide
        for _, spawnCandidate in ipairs(spawnCandidates) do
            if spawnCandidate.CanCollide then
                return spawnCandidate
            end
        end
        -- Fall back to first in list
        return spawnCandidates[1]
    else
        error("Failed to find spawn part!")
    end
end)()

LP.Character.HumanoidRootPart.CFrame = NewC(TAS[3].CCFrame[1], TAS[3].CCFrame[2], TAS[3].CCFrame[3]) * AngC(TAS[3].CCFrame[4], TAS[3].CC

local RayParts = Instance.new('Model')
RayParts.Name = "RayParts"
RayParts.Parent = Workspace

local radius = 0.05
local function MakeRayVisible(ray, color, size)
    local midpoint = ray.Origin + ray.Direction/2

    local part = Instance.new("Part")
    part.CanCollide = false
    part.CanTouch = false
    part.Parent = RayParts
    part.Anchored = true
    part.CFrame = CFrame.new(midpoint, ray.Origin)
    part.Size = size or Vector3.new(radius, radius, ray.Direction.Magnitude)
    part.Material = Enum.Material.Neon
    part.Color = color

    return part
end

local Offset = Spawn.Position - NewV(0, 1000, 0)
local DiffAnim = 0
local OldFrame = 3

local Loop
local Death

Death = LP.Character.Humanoid.Changed:Connect(function(Change)
    if Change == "Health" and LP.Character.Humanoid.Health == 0 then
        Death:Disconnect()
        Loop:Disconnect()
        RayParts:Destroy()
        CLMAIN.newAlert('Player Died.',Color3.new(1,0,0))
    end
end)

local RayParts = Instance.new('Model')
RayParts.Name = "RayParts"
RayParts.Parent = Workspace

local radius = 0.05

local function MakeRayVisible(ray,color)
    local midpoint = ray.Origin + ray.Direction/2

    local part = Instance.new("Part")
    part.CanCollide = false
    part.CanTouch = false
    part.Parent = RayParts
    part.Anchored = true
    part.CFrame = CFrame.new(midpoint, ray.Origin)
    part.Size = Vector3.new(radius,radius, ray.Direction.Magnitude)

    part.Material = Enum.Material.Neon
    part.Color = color

    return part
end

local Offset = Spawn.Position - Vector3.new(0, 1000, 0)
local DiffAnim = 0
local OldFrame = 3

local Loop
local Death

Death = LP.Character.Humanoid.Changed:Connect(function(Change)
    if Change == "Health" and LP.Character.Humanoid.Health == 0 then
        Death:Disconnect()
        Loop:Disconnect()
        RayParts:Destroy()
        CLMAIN.newAlert('Player Died.',Color3.new(1,0,0))
    end
end)

Loop = RS.Heartbeat:connect(function(DeltaTime)
    local NewFrame = #TAS
    local Divider = OldFrame + 60
    NewFrame = math.min(Divider, NewFrame)
    for i = OldFrame, NewFrame do
        if (os.clock() - TimeStart) < TAS[i].time then
            continue
        elseif i >= #TAS then
            Death:Disconnect()
            Loop:Disconnect()
            RayParts:Destroy()
            Animate.playAnimation = PlayAnim
            CLMAIN.newAlert('TAS Run Finished!',Color3.new(0,1,0))
            CLMAIN.newAlert('TAS Player By Tomato',Color3.new(0,1,0))
        elseif (os.clock() - TimeStart) >= TAS[i].time then
            OldFrame = i
            local CF = TAS[i].CCFrame
            local CCF = TAS[i].CCameraCFrame
            local VV = TAS[i].VVelocity
            if Mirrored then
                CF[3], VV[3], CCF[3] = -CF[3], -VV[3], -CCF[3]
            end
            local CA = TAS[i].AAnimation
            LP.Character.HumanoidRootPart.CFrame = CFrame.new(CF[1], CF[2], CF[3]) * CFrame.Angles(CF[4], CF[5], CF[6]) + Offset
            LP.Character.HumanoidRootPart.Velocity = Vector3.new(VV[1], VV[2], VV[3])
            Workspace.CurrentCamera.CFrame = CFrame.new(CCF[1], CCF[2], CCF[3]) * CFrame.Angles(CCF[4], CCF[5], CCF[6]) + Offset
            if TAS[i].AAnimationChanged > DiffAnim then
                if CA[1] == "walk" then
                    PlayAnim(CA[1], CA[2], LP.Character.Humanoid)
                    DiffAnim = TAS[i].AAnimationChanged
                    Animate.setAnimationSpeed(0.76)
                elseif CA[1] == "climb" then
                else
                    PlayAnim(CA[1], CA[2], LP.Character.Humanoid)
                    DiffAnim = TAS[i].AAnimationChanged
                end
           
