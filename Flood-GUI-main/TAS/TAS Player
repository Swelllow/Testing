local Mirrored = false
local SkipMirroredMaps = {
    ["Retro Coast"] = true,
    ["Zemblanity"] = true,
    ["Northren Mill"] = true,
    ["Mysterium"] = true,
    ["Decaying Silo"] = true,
    ["Active Volcanic Mines"] = true,
    ["Snowy Stronghold"] = true
}
local NewV = Vector3.new
local NewC = CFrame.new
local AngC = CFrame.fromEulerAnglesXYZ
local LP = game.Players.LocalPlayer
local Alert = getsenv(LP.PlayerScripts.CL_MAIN_GameScript).newAlert
local Multi = workspace.Multiplayer
local RS = game:GetService('RunService')
local wait = task.wait

-- IMPORTANT
local CLMAIN = getsenv(LP.PlayerScripts.CL_MAIN_GameScript)
CLMAIN.newAlert("TAS Player Started.")
local Animate = getsenv(LP.Character.Animate)
local RunName = Multi:WaitForChild('NewMap'):WaitForChild('Settings'):WaitForChild('MapName').Value
local TAS = game:GetService("HttpService"):JSONDecode(readfile(RunName .. ".json"))
CLMAIN.newAlert("TAS Loaded!")
local Map = Multi:WaitForChild("Map")
local mapName = Map:WaitForChild('Settings').MapName.Value

local HighlightPath = game:GetService("Workspace").Multiplayer.Map.Settings:FindFirstChild("Highlight")

if HighlightPath then
    CLMAIN.newAlert("Map cannot be mirrored.")
    Mirrored = false
else
    if SkipMirroredMaps[mapName] then
        CLMAIN.newAlert('Map cannot be mirrored.')
    else
        if Map:WaitForChild('Settings'):FindFirstChild("_MirrorMap") then
            CLMAIN.newAlert('Map is not mirrored.')
            Mirrored = false
        else
            CLMAIN.newAlert('Map is mirrored, TAS will be played mirrored!')
            Mirrored = true
        end
    end
end

local checkSize = function(size)
    local size = Vector3.new(math.floor(size.X), math.floor(size.Y), math.floor(size.Z))
    if size.Y == 0 and (size.X == 15 or size.X == 16) and (size.Z == 15 or size.Z == 16) then
        return true
    end
    return false
end

local Spawn = (function() -- new spawn finder by "_tomato." on discord
    local Spawn = nil
    
    local connections = {}
    for i,v in ipairs(Map:GetChildren()) do
        if v.Name == "Part" and checkSize(v.Size) == true then
            table.insert(connections, v:GetPropertyChangedSignal("Rotation"):Connect(function()
                Spawn = v
                for i,v in ipairs(connections) do
                    v:Disconnect()
                end
            end))
        end
    end
    repeat task.wait() until Spawn
    CLMAIN.newAlert("Spawn found!")
    return Spawn
end)()

--LP.Character.HumanoidRootPart.CFrame = NewC(TAS[3].CCFrame[1], TAS[3].CCFrame[2], TAS[3].CCFrame[3]) * AngC(TAS[3].CCFrame[4], TAS[3].CCFrame[5], TAS[3].CCFrame[6]) + NewV(Spawn.Position.X, Spawn.Position.Y - 1000, Spawn.Position.Z)
--LP.Character.HumanoidRootPart.Velocity = NewV(TAS[3].VVelocity[1], TAS[3].VVelocity[2], TAS[3].VVelocity[3])
--workspace.CurrentCamera.CFrame = NewC(TAS[3].CCameraCFrame[1], TAS[3].CCameraCFrame[2], TAS[3].CCameraCFrame[3]) * AngC(TAS[3].CCameraCFrame[4], TAS[3].CCameraCFrame[5], TAS[3].CCameraCFrame[6]) + NewV(Spawn.Position.X, Spawn.Position.Y - 1000, Spawn.Position.Z)

game:GetService("ReplicatedStorage").Remote.StartClientMapTimer.OnClientEvent:Wait()
local TimeStart = os.clock()
CLMAIN.newAlert('TAS Running..')
PlayAnim = Animate.playAnimation
Animate.playAnimation = function() end

for _, v in next, Map:GetDescendants() do
    if v.Name == 'ButtonIcon' then
        local buttonPart = v.Parent.Parent:FindFirstChildOfClass('Part')
        if buttonPart ~= nil then
            buttonPart.Size = Vector3.new(6,6,6)
        end
    end
end



local Offset = Spawn.Position - NewV(0, 1000, 0)
local DiffAnim = 0
local OldFrame = 3

local Loop
local Death

Death = LP.Character.Humanoid.Changed:Connect(function(Change)
    if Change == "Health" and LP.Character.Humanoid.Health == 0 then
        Death:Disconnect()
        Loop:Disconnect()
        CLMAIN.newAlert('Player Died.', Color3.new(1, 0, 0))
    end
end)

Loop = RS.Heartbeat:connect(function(DeltaTime)
    local NewFrame = #TAS
    local Divider = OldFrame + 60
    if Divider < NewFrame then
        NewFrame = Divider
    end
    for i = OldFrame, NewFrame do
        if (os.clock() - TimeStart) < TAS[i].time then
            break
        elseif i >= #TAS then
            Death:Disconnect()
            Loop:Disconnect()
            Animate.playAnimation = PlayAnim
            CLMAIN.newAlert('TAS Run Finished!', Color3.new(0, 1, 0))
            CLMAIN.newAlert('TAS Player By Tomato', Color3.new(0, 1, 0))
        elseif (os.clock() - TimeStart) >= TAS[i].time then
            OldFrame = i
            local CurrentInfo = TAS[i]
            local CF = CurrentInfo.CCFrame
            local CCF = CurrentInfo.CCameraCFrame
            local VV = CurrentInfo.VVelocity

            if Mirrored == true then
                local nCF = CF
                CF[1] = nCF[1]
                CF[2] = nCF[2]
                CF[3] = -nCF[3]
                CF[4] = -nCF[4]
                CF[5] = nCF[5]
                CF[6] = -nCF[6]
                VV[3] = -VV[3]
                CCF[3] = -CCF[3]
            end

            LP.Character.HumanoidRootPart.CFrame = NewC(CF[1], CF[2], CF[3]) * AngC(CF[4], CF[5], CF[6]) + Offset
            LP.Character.HumanoidRootPart.Velocity = NewV(VV[1], VV[2], VV[3])
            workspace.CurrentCamera.CFrame = NewC(CCF[1], CCF[2], CCF[3]) * AngC(CCF[4], CCF[5], CCF[6]) + Offset
            local CurrentAnimation = CurrentInfo.AAnimation
            if CurrentAnimation and CurrentAnimation[1] then 
                PlayAnim(CurrentAnimation[1],CurrentAnimation[2],LP.Character.Humanoid)
                if CurrentAnimation[1] == "walk" then
                    Animate.setAnimationSpeed(.76) 
                end
            end
        end
    end
end)
