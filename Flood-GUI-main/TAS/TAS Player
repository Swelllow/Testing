local Vector3_new = Vector3.new
local CFrame_new = CFrame.new
local CFrame_fromEulerAnglesXYZ = CFrame.fromEulerAnglesXYZ
local Players = game:GetService('Players')
local LP = Players.LocalPlayer
local Alert = getsenv(LP.PlayerScripts.CL_MAIN_GameScript).newAlert
local HttpService = game:GetService("HttpService")
local Multi = game.Workspace.Multiplayer
local RunName = Multi.NewMap.Settings.MapName.Value
local TAS = HttpService:JSONDecode(readfile(RunName .. ".json"))
local Map = Multi.Map
local FindPartsInRegion3 = game.Workspace.FindPartsInRegion3
local ReplicatedStorage_Remote_StartClientMapTimer = game:GetService("ReplicatedStorage").Remote.StartClientMapTimer.OnClientEvent
local os_clock = os.clock

local NewMap = Multi:WaitForChild('NewMap')
local MirrorMap = Map.Settings:FindFirstChild("_MirrorMap") ~= nil
local Mirrored = not MirrorMap

if MirrorMap then
    Alert('Map is mirrored, TAS will be played mirrored!')
end

local function FindSpawnPart()
    local character = LP.Character
    local characterPosition = character.HumanoidRootPart.Position

    local region = Region3.new(characterPosition - Vector3_new(0, 1.5, 0), characterPosition - Vector3_new(0, 2.5, 0))
    local parts = FindPartsInRegion3(game.Workspace, region, nil, 30)

    local spawnPart
    local lowestY = math.huge

    for _, part in ipairs(parts) do
        if part.Name == 'Spawn' and part.Parent == Map and not part:IsDescendantOf(NewMap) then
            if part.CanCollide and part.Transparency >= 0.8 then
                spawnPart = part
                break
            elseif not part.CanCollide then
                spawnPart = part
                local partY = part.Position.Y
                if partY < lowestY then
                    lowestY = partY
                end
            end
        end
    end

    if spawnPart == nil then
        error("Failed to find spawn part!")
    end

    local spawnPosition = spawnPart.Position
    return spawnPosition.X, lowestY or spawnPosition.Y, spawnPosition.Z
end

local spawnX, spawnY, spawnZ = FindSpawnPart()
local characterCFrame = CFrame_new(TAS[3].CCFrame[1], TAS[3].CCFrame[2], TAS[3].CCFrame[3])
    * CFrame_fromEulerAnglesXYZ(TAS[3].CCFrame[4], TAS[3].CCFrame[5], TAS[3].CCFrame[6])
    + Vector3_new(spawnX, spawnY - 1000, spawnZ)

LP.Character.HumanoidRootPart.CFrame = characterCFrame
LP.Character.HumanoidRootPart.Velocity = Vector3_new(TAS[3].VVelocity[1], TAS[3].
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")
local RS = game:GetService("RunService")
local LP = game:GetService("Players").LocalPlayer

local Map = Workspace.Multiplayer.Map
local Spawn = Map.Settings["_GameSpawnLocation"].Value

local CLMAIN = require(ReplicatedStorage.Modules.Client.Main)
local Animate = require(ReplicatedStorage.Modules.Client.Animate)
local PlayAnim = Animate.playAnimation
Animate.playAnimation = function() end

local debugmode = true
local Mirrored = false

local function NewV(x, y, z)
    return Vector3.new(x, y, z)
end

local function NewC(x, y, z)
    return CFrame.new(x, y, z)
end

local function AngC(x, y, z)
    return CFrame.Angles(x, y, z)
end

local function MakeRayVisible(ray, color)
    local midpoint = ray.Origin + ray.Direction / 2
    local part = Instance.new("Part")
    part.CanCollide = false
    part.CanTouch = false
    part.Parent = RayParts
    part.Anchored = true
    part.CFrame = CFrame.new(midpoint, ray.Origin)
    part.Size = Vector3.new(0.05, 0.05, ray.Direction.Magnitude)
    part.Material = Enum.Material.Neon
    part.Color = color
    return part
end

local function GetDescendantsWithName(root, name)
    local descendants = root:GetDescendants()
    local matchingDescendants = {}
    local numMatchingDescendants = 0
    for i = 1, #descendants do
        local descendant = descendants[i]
        if descendant.Name == name then
            numMatchingDescendants = numMatchingDescendants + 1
            matchingDescendants[numMatchingDescendants] = descendant
        end
    end
    return matchingDescendants
end

local function SetButtonPartSize(buttonPart)
    if buttonPart == nil then
        return
    end
    buttonPart.Size = Vector3.new(6, 6, 6)
    if debugmode then
        buttonPart.Color = Color3.new(0, 0, 1)
        buttonPart.Transparency = 0
    end
end

local RayParts = Instance.new("Model")
RayParts.Name = "RayParts"
RayParts.Parent = Workspace

local Offset = Spawn.Position - NewV(0, 1000, 0)
local DiffAnim = 0
local OldFrame = 3

local TAS = {}
local function LoadTAS()
    local remoteFunction = ReplicatedStorage.RemoteFunction.StartTAS
    TAS = remoteFunction:InvokeServer()
    for i = 1, #TAS do
        local function ToCFrame(CF)
            return NewC(CF[1], CF[2], CF[3]) * AngC(CF[4], CF[5], CF[6]) + Offset
        end
        local origin = ToCFrame(TAS[i].CCFrame).Position
        local ray = Ray.new(origin, ToCFrame(TAS[i].CCFrame).Position - origin)
        MakeRayVisible(ray,Color3.new(1,0,0))
    end
end

 game:GetService("Workspace").Multiplayer.Map.Settings["_MirrorMap"]
